# 数组
## 二分查找
**能解决的问题：** 找到第一个复合要求的元素，第一个大于target的元素，过程中根据判断条件不断缩小左右边界，缩小寻找范围。

**暴力做法查找：** 全部遍历O(n)，没有利用有序的性质

**前提：** 如果数据有序，可以考虑二分查找。如果有重复，不保证唯一答案。

**注意的点：** 循环不变量

**时间复杂度** ：O(logn)
- 每次把问题规模砍半直到剩一个元素
- n/2^k = 1 -> k = log(n)
- 最多O(logn)次查询

**几种实现方法**： 左闭右闭，左闭右开

[704 二分查找](https://leetcode.cn/problems/binary-search/description/)
<details>

```

// 左闭右闭写法
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length -1;
        while(left<= right){
            int mid = left + (right -left)/2;
            if(nums[mid] < target){ //易错：mid是下标，要比较nums[mid]
                left = mid +1;
            }
            else if(nums[mid]>target){
                right = mid -1;
            }
            else{
                return mid;
            }
        }
        return -1;
    }
}

// 左闭右开写法
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length -1;
        while(left< right){
            int mid = left + (right -left)/2;
            if(nums[mid] < target){ //易错：mid是下标，要比较nums[mid]
                left = mid +1;
            }
            else if(nums[mid]>target){
                right = mid;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
}

// 错题
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        while(left< right){
            int mid = left + (right -left)/2;
            if(nums[mid] < target){
                left = mid +1;
            }
            if(nums[mid]>target){ // if与下一个else 配对，没有互斥，逻辑错误
                right = mid;
            }
            else{
                return mid;
            }
        }
        return -1;
    }

```
</details>

## 有序数组平方

[移除元素](https://leetcode.cn/problems/squares-of-a-sorted-array/)

<details>

**问题:** 给一个非递减数组，每个数字平方后同样返回非递减数组。

**暴力排序：** 每个数字平方后用sort()排序。java sort() 时间复杂度是O(nlogn)

```
    public int[] sortedSquares(int[] nums) {
        for(int i = 0; i < nums.length; i ++){
            nums[i] = nums[i] * nums[i];
        }
        Arrays.sort(nums);
        return nums;
    }
```

**双指针法：**

**思路：** 
- 两边绝对值最大，平方后也最大。双指针指向两边。
- 一个和原数组一样长的result数组，指针指向最右边
- left和right指针指向原数组左右，挑选出来最大的平方，加入result

**时间复杂度:** O(n)遍历一遍数组

```
  public int[] sortedSquares(int[] nums) {
      int[] ret = new int[nums.length];
      int left = 0, right = nums.length-1, i = nums.length -1;
      while(left <= right){
          int leftSquare = nums[left]* nums[left];
          int rightSquare = nums[right]* nums[right];
          if(leftSquare >= rightSquare){
              ret[i] = leftSquare;
              left++;
          }
          else{
              ret[i] = rightSquare;
              right--;
          }
          i --;
      }
      return ret;
  }
```

</details>

## 移除元素

[27移除元素](https://leetcode.cn/problems/remove-element/)

**能解决的问题：** 原地从数组里删除

<details>

**暴力解法：**
- 时间复杂度：O(n^2)
```
  public int removeElement(int[] nums, int val) {
      int size = nums.length;
      for(int i = 0; i < size; i ++){
          if (nums[i] == val){
              for(int j = i + 1; j < size; j++){
                  nums[j-1] = nums[j];
              }
              i--; // 删除当前元素，后面的向前移了一位
              size --;
          }
      }
      return size;
  }
```
**双指针:**
- 思路：快指针遍历当前数组，慢指针收集结果数组，实际使用同一个数组空间。
```
  public int removeElement(int[] nums, int val) {
      int slow = 0, fast = 0;
      while(fast < nums.length){
          if(nums[fast] != val){
              nums[slow] = nums[fast];
              slow++;
          }
          fast++;
      }
      return slow;
  }
```

</details>

## 长度最小的子数组

题目：找出何为n长度最小的子数组

<details>

https://leetcode.cn/problems/minimum-size-subarray-sum/

暴力解法：O(n^2) 两个for循环，外层子序列的起点，里面便利子序列终点，曲最短的结果

滑动窗口：

思路：遍历j是窗口结束的位置。**不变量**窗口内总和满足条件，如果满足就不断缩小窗口更新最小值。

时间复杂度：O(n) 两个指针一起走了2n的距离

空间复杂度: O(1)

```
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int slow = 0;
        int ret = Integer.MAX_VALUE;
        int sum = 0;
        for(int fast = 0; fast < nums.length; fast++){
            sum += nums[fast];
            System.out.println(fast + "|" + slow);   //DEBUG指针移动
            while(sum >= target){
                ret = Math.min(ret, fast - slow + 1);
                sum -= nums[slow];
                slow++;
            }
        }
        return ret < Integer.MAX_VALUE ? ret : 0;
    }
}

```

错题本：

```
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int slow = 0;
        int ret = Integer.MAX_VALUE;
        int sum = 0;
        for(int fast = 0; fast < nums.length; fast++){
            sum += nums[fast];
            System.out.println(fast + "|" + slow); 
            while(sum >= target){
                sum -= nums[slow];
                slow++;
                ret = Math.min(ret, fast - slow + 1); // 这里长度计算不对，少了1，slow先动了
            }
        }
        return ret < Integer.MAX_VALUE ? ret : 0;
    }
}

```
</details>

## 螺旋矩阵

https://leetcode.cn/problems/spiral-matrix-ii/


思路：
- 保持左闭右开的循环不变两，不处理尾巴的元素。
- 一圈为一个迭代, n*n 一共转n/2圈
- 指针初始位置0,0 下一次1,1 下一次2,2 开始位置用starx, stary两个变量。offset控制边长/结尾。
- 分奇数和偶数情况，奇数情况中心格子不会被遍历到要手动填入
- i j两个指针画圈遍历

时间复杂度：O(n^2) 矩阵遍历时间

空间复杂度：O(1)

<details>

```
public int[][] generateMatrix(int n) {
        int startx = 0, starty = 0;
        int offset = 1;
        int circles = n / 2;
        int[][] matrix = new int[n][n];
        int cnt = 1; //用来赋值
        while(circles-- > 0){
            int j = starty;
            int i = startx;
            for(; j < n-offset; j++){
                matrix[i][j] = cnt++;
            }
            for(; i < n-offset; i++){
                matrix[i][j] = cnt++;
            }
            for(; j > starty; j --){
                matrix[i][j] = cnt++;
            }
            for(;i>startx; i --){
                matrix[i][j] = cnt++;
            }
            startx++;
            starty++;
            offset++;
        }
        if(n%2 ==1){
            matrix[startx][starty] = cnt;
        }
        return matrix;
    }

```

</details>

## 区间和

https://kamacoder.com/problempage.php?pid=1070

问题：数组里任意区间的和，用区间和很高效O(1)查询时间，不用重复遍历查询

思路：

- 构建前缀和数组，p[n] 表示0-n和
- b - a = p[b] - p[a-1]

<details>

```
    public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for(int i = 0; i <n; i++){
            nums[i]= scanner.nextInt();
        }
        int[] numSum = new int[n];
        int sum = 0;
        for(int i =0; i < n; i++){
            sum += nums[i];
            numSum[i] = sum;
        }
        while(scanner.hasNextInt()){ //不能用hasNextLine()
            int start = scanner.nextInt();
            int end = scanner.nextInt();
            int result;
            if(start == 0){ //0 要单独处理，不然后面汇报iob
                result = numSum[end];
            }else{
                result = numSum[end] - numSum[start-1];
            }
            System.out.println(result);
        }
    }
}
```
    
</details>

## 开发商购买土地

https://kamacoder.com/problempage.php?pid=1044

思路：
- 横或竖一刀怎么让绝对差最小
- 求每一列，每一行的前缀和，方便后面去算总面积. horizontal[i] 第i行的和， vertical[j]第j列的和
- 取总面积差最小的方式

<details>
    
```
import java.util.*;

public class Main{
    public static void main(String args[]){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] land = new int[n][m];
        int totalArea = 0;
        for(int i = 0; i <n; i ++){
            for(int j =0; j <m; j++){
                land[i][j] = scanner.nextInt();
                totalArea += land[i][j];
            }
        }

        int[] horizontal = new int[n];
        for(int i = 0; i < n; i++){
            for(int j = 0; j <m; j++){
                horizontal[i] += land[i][j];
            }
        }
        int[] vertical = new int[m];
        for(int j = 0; j <m; j++){
            for(int i = 0; i <n; i++){
                vertical[j] += land[i][j];
            }
        }

        int ret = Integer.MAX_VALUE;
        int split = 0;
        for(int i = 0; i < n; i++){
            split += horizontal[i];
            int diff = Math.abs(split - (totalArea - split));
            ret = Math.min(ret, diff);
        }

        split = 0;
        for(int j = 0; j < m; j++){
            split += vertical[j];
            int diff = Math.abs(split - (totalArea - split));
            ret = Math.min(ret, diff);
        }
        System.out.println(ret);
    }
}
    
```
    
</details>

## 有效字符的异位词

https://leetcode.cn/problems/valid-anagram/

思路：
- 26长度数组映射每个字母出现字数
- 一个数组做++， 一个做--
- 判断结果是不是都为0

时间复杂度：O(n)
空间复杂度：O(1)

暴力解法：遍历两个数组 O(n^2) 时间

注意：熟练String的方法

```

class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int [26];
        for(int i = 0; i < s.length(); i++){
            int c = s.charAt(i) - 'a';
            record[c] += 1;
        }

        for(int i = 0; i < t.length(); i++){
            int c = t.charAt(i) - 'a';
            record[c] -= 1;
            if(record[c] < 0) return false; // early return
        }
        for(int i = 0; i < 26; i++){
            if(record[i] != 0) return false;
        }
        return true;
    }
}

```

