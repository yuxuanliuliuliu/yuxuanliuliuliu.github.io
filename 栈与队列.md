## 删除相邻重复字符
https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/

思路：
- 用deque来记录遍历的字符
- 如果和栈顶一有，栈顶pop
- 栈为空，或者不一样 push

注意：

- 判断相邻的都可以用栈的结构

- 可以用stringBuilder替换栈，stringBuilder不是多线程安全的但是比stringBuffer块。

## 有效括号

https://leetcode.cn/problems/valid-parentheses/submissions/687211837/

思路：
- 用栈记录便利过的左括号，加入它对应的右括号
- 中间发现不匹配，栈为空return false
- 最后判断栈要是空的return true
- 剪纸：长度奇数

时间复杂度：O(n)

空间复杂度: O(n)

注意：
- 用arrayDeque 底层是数组，linkedList里面是node有前后指针

错题：
```
        if(c == '('){
            chars.add(')'); //add等同于addLast() 用push等同于addFirst()
        }
```

## 用队列实现栈

https://leetcode.cn/problems/implement-stack-using-queues/

时间复杂度：pop() top() 都是O(n) 其他O(1)

空间复杂度：O(n)

思路：
- 用一个队列
- pop() 把前面的都removeFirst()出来再从尾巴加进去addLast()。
- top()用peekLast()
- 也可以用两个队列。

注意：
- 用arrayDeque() 实现队列
- 用addLast() removeFirst() 模拟队列

错题：
```
    public int top() {
        return this.q.peekFirst(); //要用peeklast()
    }
```

## 用栈实现队列

https://leetcode.cn/problems/implement-queue-using-stacks/

思路：
- 分入栈和出栈
- pop()出栈，如果出栈没有元素，入栈全部加进出栈
- empty()入栈和出栈都为空

时间复杂度：都是O(1)，pop() peek()循环一次被n次查询分摊

空间复杂度：O(n)

注意：
- java 推荐用 Deque<Integer> stack = new ArrayDeque<>(); 比stack高效一点。
- add() remove() 模拟栈

错题：
```
    public int pop() {
        while(!this.outStack.isEmpty()){ //判断入栈是否为空，这样出栈加一个循环就结束了。
            this.outStack.push(this.inStack.pop());
        }
        return this.outStack.pop();
    }

    public boolean empty() {
        return this.outStack.isEmpty(); // 入栈出栈都要判断
    }
```
