## 前K个频率的元素

https://leetcode.cn/problems/top-k-frequent-elements/

思路：
- 遍历得K-V频率表
- 构建小顶堆，保持堆的数量为K，把小的元素都弹出去
- 倒叙构建结果数组

时间复杂度: O(nlogk)遍历所有元素，每个元素加入pq然后排序log(k)

空间复杂度：O(n) map记录所有元素

```
// 构建pq的方法，队列存Map.Entry<Integer, Integer>。
PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> Integer.
compare(a.getValue(), b.getValue()));
```

注意：

- 关于comparator. pq在poll的时候会去使用comparator取一个最小的值出来

## 滑动窗口最大值

https://leetcode.cn/problems/sliding-window-maximum/submissions/687409270/

暴力：O(n*k) 每个数便利当前k长的窗口

时间复杂度：O(n) 遍历整个数组

空间复杂度: O(k) 队列长度K

思路：
- 维护一个队列一进一出，每次告诉我们最大值是什么
- 队列有push()添加元素, pop()移除元素, front() 最大值在最前面，保持队列单调递减出口处是最大值
- push() 要和队尾做对比，比队尾大，移除队尾
- pop() 队首对比，相同移除头部

注意：
- when you pass an object, the value passed in is the reference, caller and callee
  point to the same object, change is seen by the caller
- result.stream().mapToInt(Integer::intValue).toArray(); 用stream array转化为数组

错误：

```
    void push(int value, Deque<Integer> dq){
        while(!dq.isEmpty() && value > dq.peek()){ //要peekLast，入口处是尾巴
            dq.remove(); //removeLast
        }
        dq.add(value);
    }
```

## 逆波兰表达式

https://leetcode.cn/problems/evaluate-reverse-polish-notation/

时间复杂度：O(n) 遍历一遍表达式

空间复杂度: O(n)

思路：
- 用栈遍历表达式
- 有运算符消掉两个数字，再把运算结果入栈

注意：
- String to int, Integer.parseInt()返回primitive int; Integer.valueOf()返回Integer 自动unbox
- String literals are stored in the String Pool. identical literals point to the same object so ==
- "-" != '-' 不一样类型
  
## 删除相邻重复字符
https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/

思路：
- 用deque来记录遍历的字符
- 如果和栈顶一有，栈顶pop
- 栈为空，或者不一样 push

时间复杂度: O(n) 都遍历一遍

空间复杂度: O(n)

注意：

- 判断相邻的都可以用栈的结构

- 可以用stringBuilder替换栈，stringBuilder不是多线程安全的但是比stringBuffer块。

## 有效括号

https://leetcode.cn/problems/valid-parentheses/submissions/687211837/

思路：
- 用栈记录便利过的左括号，加入它对应的右括号
- 中间发现不匹配，栈为空return false
- 最后判断栈要是空的return true
- 剪纸：长度奇数

时间复杂度：O(n)

空间复杂度: O(n)

注意：
- 用arrayDeque 底层是数组，linkedList里面是node有前后指针

错题：
```
        if(c == '('){
            chars.add(')'); //add等同于addLast() 用push等同于addFirst()
        }
```

## 用队列实现栈

https://leetcode.cn/problems/implement-stack-using-queues/

时间复杂度：pop() top() 都是O(n) 其他O(1)

空间复杂度：O(n)

思路：
- 用一个队列
- pop() 把前面的都removeFirst()出来再从尾巴加进去addLast()。
- top()用peekLast()
- 也可以用两个队列。

注意：
- 用arrayDeque() 实现队列
- 用addLast() removeFirst() 模拟队列

错题：
```
    public int top() {
        return this.q.peekFirst(); //要用peeklast()
    }
```

## 用栈实现队列

https://leetcode.cn/problems/implement-queue-using-stacks/

思路：
- 分入栈和出栈
- pop()出栈，如果出栈没有元素，入栈全部加进出栈
- empty()入栈和出栈都为空

时间复杂度：都是O(1)，pop() peek()循环一次被n次查询分摊

空间复杂度：O(n)

注意：
- java 推荐用 Deque<Integer> stack = new ArrayDeque<>(); 比stack高效一点。
- add() remove() pop() 模拟栈

错题：
```
    public int pop() {
        while(!this.outStack.isEmpty()){ //判断入栈是否为空，这样出栈加一个循环就结束了。
            this.outStack.push(this.inStack.pop());
        }
        return this.outStack.pop();
    }

    public boolean empty() {
        return this.outStack.isEmpty(); // 入栈出栈都要判断
    }
```
