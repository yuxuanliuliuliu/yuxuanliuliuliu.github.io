## 进程的同步和互斥
1220 q3增加同步 出了数据混乱问题，提一下生产消费不同步问题，例子有点啰嗦。

多个线程竞争共享资源会导致共享数据混乱。**竞争条件 race condition** 在操作过程中发生上下文切换，导致结果不确定。多进程同样会有这种情况。

方法：
**临界区 critical section** 共享代码片段，一定不能给多个线程执行。这段代码是**互斥 mutual exclusion**
**线程/进程同步**希望线程按一定顺序执行，相互等待互相通信。
**锁** 加锁解锁
    - 忙等锁：一直获取不到锁一直在while里面等，spin lock. 自旋会一直利用cpu周期，需要抢占是调度器time interrupt把控制权交给别人。
    - 无忙等锁：不用自旋，放到等待队列里把线程设置成等待状态

使用testAndSet()实现忙等锁

**信号量** P、V，比锁更多能一点可以实现同步和互斥，通常表示资源的数量，对应一个整型。
- P -1, if sem<0, 进程进入阻塞状态，会阻塞
- V +1 if sem <=0, 唤醒一个等待进程，V不会阻塞
- P V 是由操作系统实现的，具有原子性，P V包裹临界区域

信号量实现互斥 Semaphore s = 1；1 表示没有线程在，0表示有一个线程在，-1 表示一个线程在临界区，另一个在等待

生产者消费者问题：

实现同步 初始0；

## 用户态和内核态

为避免用户程序直接进行硬件操作，这样很危险内存磁盘可能都会被改掉。所以程序实际上通过操作系统的内核这一桥梁来链接硬件设备。内核是操作系统的核心部分，它
有很高的权限。操作系统会把内存分成两个区域。内核空间给内核程序用，用户空间给应用程序用。内核有很高的权限，这里的代码可以访问
所有的内存空间，但是用户空间的不可以。当程序使用用户空间的时候，在用户态。使用内核空间是在内核态。这两种状态是可以切换到。如果程序要切换到内核态去往磁盘里写东西，
它可以中断当前的用户程序通过中断指令trap跳到去处理中断程序，开始内核态的工作。内核处理完会把cpu执行权返还给用户程序。 

内核里面做的事情有：
- 管理进程，线程，调度，决定哪个进程被cpu处理
- 管理内存，分配和回收
- 硬件设备，进程和硬件之间的用信能力
- 系统调用，应用程序可以通过系统调用获得更高运行权限

进入内核态的方式
- 系统调用，主动进入比如read命令
- 运行错误，cpu自动切换到内核态
- 外部的中断如时钟中断

用户态下，cpu只能和执行部分指令，无法直接访问硬件资源。内核态下，cpu可以执行左右指令访问所有资源。

## 并发和并行
一段时间可以执行多个任务是并发，单核cpu实际是快速切换的执行，但是程序感知不到。时间遍轮转，调度机制切换任务

同时处理多个任务需要多核cpu，这就是并行。并行的单个cpu上也可以有并发。

并行不一定比并发更快。并发主要是拉满一个cpu的利用率，一有阻塞就换任务。考虑io等待的操作用但线程并发更好。

## 进程和线程之间有什么区别
<details>

进程和线程的定义区别：
在操作系统里面，进程就是一个正在执行的程序. 当我们在电脑上打开很多程序的时候，操作系统就会同时创建了许多的进程。可以理解为是资源分配的最小单位，因为操作系统会给每一个进程分配独立的内存空间，配置输入输出流等等运行这个程序需要的所有资源。所以在进程实际是一种数据结构，记录内存地址，CPU寄存器值，虚拟地址，进程的状态等等，这个数据结构就是PCB进程控制快。与之对比的是线程。这里在一个包含的关系，进程之下可以运行一条或者多条线程。可以想一下一份代码从上到下的运行到结尾。
下一行等着上一行运行结束再执行，这是一条线程。另一种就是多线程。统一分代码不同的方法他们俩就分开运行，各自不依赖对方，这也能提高效率。线程是cpu最小的调度单位，它包换cpu执行要的代码，寄存器，计数器，多余的就没有了。这也是每个线程独立的信息。

如果程序只执行一个流程代表他是单线程的，有多个执行流程就是多线程，线程是调度的基本单位。线程之间代码，堆空间，打开的文件是共享的，栈和寄存器是独有的。

效率区别：
和进程的区别就是。计算机不会为线程分配那么多资源。如果一个进程中有很多线程在运行，这些线程会共享一个进程的虚拟内存。这包括代码、文件、全局变量，文件的管理等，但他们也有一部分独立的东西。比如寄存器， 栈。所以计算机在创建线程时比进程简单，因为它不需要开辟新空间，很多资源各个线程之间共享，同理在销毁，创建的时候县城需要创建和释放的资源就比进程要少。所以线程比进程更有效率。但是相对来说，安全性没有那么高。进程的失败不会影响别的进程但是线程就会。

上下文切换区别：
我们需要进程和县城的目的都是想并发的执行程序。为了提高CPU的利用效率，让CPU执行这个程序一段时间，然后执行别的程序一段时间再来执行这个，而不是卡死在一个程序当中. 这个切换的过程需要频繁上下文切换. 进程和现成的上下文切换也有不同的特性。晋城之下的上下文切换。计算机需要替换的东西就比线程要多，除了CPU的寄存器和程序技术，这是进程和县城都有的，进程还需要替换比如页表，文件。因为每个进程独有的一份不一样的。上下切换的时候这些资源都需要替换。但是在线程里只需要替换不共享的部分。

通信区别：
再说一下关于进程间通信和线程之间的通信。
进程间的通信比较麻烦，一般需要借助内核空间，因为内核是管理进程的更上一个层级系统。一种方式就是在内核中的管道沟通就是grep。一个进程可以向管道的一端发送消息，另外一个进程从另外一段收到消息，还有一种方式是消息对立，因为管道是没有格式化的自节流管道命令，对于这一点是一个提升用户可以发送自定义的数据结构，这个时候就需要发送者和接收，提前商定好这个内容格式，还有一种通信方式就是通过内核的存储空间进程共同访问存储空间通过里面读写数据来实现交流。这里举例三种方式县城之间的沟通交流就来得简单很多，因为本来他们就会共享内存，所以可以通过使用全局变量互通

并发操作要注意的问题：
不管是多个线程还是多个进程，在访问同一个资源的时候都需要特殊处理，防止竞争条件和考虑并发一致性的问题。我举几个处理的例子一个就是信号量在C语言里面是semaphore，他的概念是一个全局的计数器能，控制访问有多少进程或者线程正在访问这个资源，还提供这两个系统原子性操作P和V保证并发的安全。


Process is OS's abstraction of a running program. When we run multiple program at the same time, multiple processes
are run concurrently on the same system. Instructions of one process are interleaved with instructions of another process.
This is achieved by mehcanism known as context switching. A uniprocessor system only execute one program code at a time, while multicore can execute
several programs simultaneously. Processes abstracts over processor, main memory, IO devices.

Threads: a rpcess can consist of multiple threads, each running in the contect of the process, share same code and global data. 
Easier to share data between threads and more efficient. Multiple control flow within a process.

concurrency: a system with multiple, simultaneous activities. interleaving execution.

parallelism: use of concurrency to make system run faster. multiple processes running different cores.
- thread level paralellism

  Multicore processors: have several cpus or cors.

  hyperthreading: allows a single cpu to execute multiple threads/ flows of control.

instruciton level parallelism
  - processors execute multiple instructions at one time

</details>

## 进程间的通信
<details>
  管道：匿名管道，一种先进先出的内核文件，进程创建之后可以有读写的描述符进行读写消息，这种匿名的只可以从父进程继承多来，创建的时候把文件给儿子。命名管道，创建一个文件，可以通过文件名使用它，任意进程都可以使用。数据存储在内核里面。
  效率不高。
  
  队列：创建内核中的队列，可以自定义数据结构，需要接受和发送达成一致。这个发送接收消息都是一次系统调用要切换用户态和内核态，开销比较大。
  
  共享内存：本来虚拟地址到物理地址的映射不一样的，一个虚拟空间映射到相同的物理内存里面，不需要一直拷贝。

  信号量：共享内存会有冲突，资源竞争的问题。保证并发的一致性，信号量是一种方式。编程用的semaphore。它一个特殊的计数器，规定这个资源能同时被多少人用，也可以达到程序互斥的目的，
  P操作是-1, V操作是+1，这两个都是原子操作。信号量初始化为1，使用时候做P -1 的操作，<=0表示被占有。 V释放后<0 还有其他在等待，可以唤起。>0表示没有阻塞。0是同步信号，

  信号：处理异常的情况。kill -9 发送编号9的信号给一个进程，用来立即结束它。可以查看具体有几十种信号。有这个信号，系统或者程序收到后做对应的造作，比如终止进程，信号处理函数。

  socket: 跨网络通信。创建socket配置不同网络的通信方式。常见在客户端和服务端之间。可以配置基于TCP/IP字节流或者UDP数据报不同类型或者本地通信的socket。他们的编程模式不一样。tcp有三次握手。
  
</details>
