## 虚拟内存
允许程序访问比实际内存更大的空间，每个程序有足够的内存运行。

进程都不能访问到物理地址，虚拟地址到物理地址对于程序来说是透明的。虚拟地址通过MMU映射到物理地址。
有两种方式，内存分段：不同的段有不同属性eg代码分段，堆栈。虚拟地址被分成4个段。问题是内存碎片。应为没有连续的内存空间，哪怕释放了也无法被利用。
可以把一段存进磁盘在读出来。这样内存交换率是很低的。

内存分页：
会有内部碎片

## 锁的种类

背景：多线程访问共享资源避免不了竞争情况，为了解决这个问题，我们都会在访问共享资源之前给它加个锁。

加锁的目的：保证共享资源在任一时间只有一个线程访问，避免数据错乱。

最底层的两种锁：互斥锁和自旋锁。当一个线程加锁后，另外一个线程重复加锁就会失败。这两个的失败处理方式不一样。

互斥锁加锁失败后，线程会释放cpu切换给其他线程运行, 线程会被内核设置成睡眠状态，等锁被释放后，内核会再把它唤醒，成功获取锁后就可以继续执行了。
这里的开销就是1. 内核把线程从运行设置到睡眠，然后切换cpu给别的进程。2. 锁被释放后，切换睡眠状态到就绪状态再切换cpu的时间。会发生的问题就是上下文切换的时间比锁住进程执行的时间还要长。
性能消耗大。

自旋锁失败后，线程会忙着等待知道它拿到锁。 通过CPU CAS函数，在用户态里完成加锁和解锁操作。开销相对少一些。加锁的两个步骤1: 查看锁的状态，如果空闲进行第二部 2: 把锁设置成当前进程持有
这两个指令被cas函数和为一个原子指令 - 一次性完成所有步骤，要么都不执行。加锁失败的线程可能会忙等待，知道它拿到锁，像是while 循环。自旋锁不会放弃cpu所以，单核cpu需要抢占式
的调度器中断它让其他线程运行。自旋和被锁代码执行时间成正比的，这个时间自旋线程会一直占用cpu。

总结：面对加锁失败，一个用线程切换，一个用忙等待带对应。这是锁最基本的形态，别的是衍生。

读写锁：读取资源用读锁，修改资源用写锁，区分读写操作。

工作原理：
- 写锁没被持有时候，任何多线程都可以持有读锁访问资源，这很有道理因为读不会破坏资源，这样可以提高读的效率。
- 一旦写锁被持有，获取读锁和写锁都会被阻塞。
写锁是独占的，读锁是共享的。

更细分为：
- 读优先锁：如果有线程在读，别的写线程会被阻塞，过程中还可以加别的读锁。写线程会造成饥饿现象
- 写优先锁：获取锁的时候，有线程在读，会等他读完，然后写线程成功获取锁，中间有别的读线程获取锁会被阻塞。

更公平一点，用一个列队让他们排队谁也不回饥饿。

上面都是悲观锁假设冲突概率高。

乐观锁与悲观锁：冲突概率很低的情况下，乐观锁实用。它让你先修改资源结束后在验证有没有冲突。如果没有操作完成，有的话就放弃这次操作。放弃之后可以再重试这次操作。
就像git用了乐观锁，发生冲突后要我们自己修改完提交。乐观锁完全除去加锁解锁的操作，但是发生冲突后重试成本高。

加锁的颗粒度要小。

## 死锁
todo: java jstack

背景：为了防止多线程竞争共享资源导致数据混乱，我们会给共享资源加上互斥锁，只有成功得到锁的线程才能操作资源，没拿到的线程要乖乖等待。

这会导致的问题： 有一种情况两个线程都在等待状态等对方释放锁，没有外力，就会一直等待，这就是死锁。两个或者以上并发

解释死锁：互斥性，多个线程不可以同时使用一个资源。 不可剥夺，在使用完前不会被其他线程获取到。 环路，a-1 b-2 a等2 b等1 持有并等待：线程在等待的时候并不会释放资源

排查死锁：java jstack, 显示程序执行堆栈信息，如果一直没有变动大概率是死锁因为在等待锁

避免死锁： 
- 避免死锁会发生的情况。打破环路，将资源有序分配，打破死锁，都要遵循先获取a 在获取b的顺序不可以反着来
  
## 进程的同步和互斥
todo: 增加同步说明， 目的除了数据混乱问题，还有生产消费同步问题。例子有点啰嗦。了解哲学家吃面哪一段代码。

多个线程竞争共享资源会导致共享数据混乱。**竞争条件 race condition** 在操作过程中发生上下文切换，导致结果不确定。多进程同样会有这种情况。

方法：
**临界区 critical section** 共享代码片段，一定不能给多个线程执行。这段代码是**互斥 mutual exclusion**
**线程/进程同步**希望线程按一定顺序执行，相互等待互相通信。
**锁** 加锁解锁
    - 忙等锁：一直获取不到锁一直在while里面等，spin lock. 自旋会一直利用cpu周期，需要抢占是调度器time interrupt把控制权交给别人。
    - 无忙等锁：不用自旋，放到等待队列里把线程设置成等待状态

使用testAndSet()实现忙等锁

**信号量** P、V，比锁更多能一点可以实现同步和互斥，通常表示资源的数量，对应一个整型。
- P -1, if sem<0, 进程进入阻塞状态，会阻塞
- V +1 if sem <=0, 唤醒一个等待进程，V不会阻塞
- P V 是由操作系统实现的，具有原子性，P V包裹临界区域

信号量实现互斥 Semaphore s = 1；1 表示没有线程在，0表示有一个线程在，-1 表示一个线程在临界区，另一个在等待

生产者消费者问题：

实现同步 初始0；

## 用户态和内核态

为避免用户程序直接进行硬件操作，这样很危险内存磁盘可能都会被改掉。所以程序实际上通过操作系统的内核这一桥梁来链接硬件设备。内核是操作系统的核心部分，它
有很高的权限。操作系统会把内存分成两个区域。内核空间给内核程序用，用户空间给应用程序用。内核有很高的权限，这里的代码可以访问
所有的内存空间，但是用户空间的不可以。当程序使用用户空间的时候，在用户态。使用内核空间是在内核态。这两种状态是可以切换到。如果程序要切换到内核态去往磁盘里写东西，
它可以中断当前的用户程序通过中断指令trap跳到去处理中断程序，开始内核态的工作。内核处理完会把cpu执行权返还给用户程序。 

内核里面做的事情有：
- 管理进程，线程，调度，决定哪个进程被cpu处理
- 管理内存，分配和回收
- 硬件设备，进程和硬件之间的用信能力
- 系统调用，应用程序可以通过系统调用获得更高运行权限

进入内核态的方式
- 系统调用，主动进入比如read命令
- 运行错误，cpu自动切换到内核态
- 外部的中断如时钟中断

用户态下，cpu只能和执行部分指令，无法直接访问硬件资源。内核态下，cpu可以执行左右指令访问所有资源。

## 并发和并行
一段时间可以执行多个任务是并发，单核cpu实际是快速切换的执行，但是程序感知不到。时间遍轮转，调度机制切换任务

同时处理多个任务需要多核cpu，这就是并行。并行的单个cpu上也可以有并发。

并行不一定比并发更快。并发主要是拉满一个cpu的利用率，一有阻塞就换任务。考虑io等待的操作用单线程并发更好。把任务分配给不同cpu是耗费时间的。

## 进程和线程之间有什么区别
<details>

进程和线程的定义区别：
在操作系统里面，进程就是一个正在执行的程序. 当我们在电脑上打开很多程序的时候，操作系统就会同时创建了许多的进程。可以理解为是资源分配的最小单位，因为操作系统会给每一个进程分配独立的内存空间，配置输入输出流等等运行这个程序需要的所有资源。所以在进程实际是一种数据结构，记录内存地址，CPU寄存器值，虚拟地址，进程的状态等等，这个数据结构就是PCB进程控制快。与之对比的是线程。这里在一个包含的关系，进程之下可以运行一条或者多条线程。可以想一下一份代码从上到下的运行到结尾。
下一行等着上一行运行结束再执行，这是一条线程。另一种就是多线程。统一分代码不同的方法他们俩就分开运行，各自不依赖对方，这也能提高效率。线程是cpu最小的调度单位，它包换cpu执行要的代码，寄存器，计数器，多余的就没有了。这也是每个线程独立的信息。

如果程序只执行一个流程代表他是单线程的，有多个执行流程就是多线程，线程是调度的基本单位。线程之间代码，堆空间，打开的文件是共享的，栈和寄存器是独有的。

效率区别：
和进程的区别就是。计算机不会为线程分配那么多资源。如果一个进程中有很多线程在运行，这些线程会共享一个进程的虚拟内存。这包括代码、文件、全局变量，文件的管理等，但他们也有一部分独立的东西。比如寄存器， 栈。所以计算机在创建线程时比进程简单，因为它不需要开辟新空间，很多资源各个线程之间共享，同理在销毁，创建的时候县城需要创建和释放的资源就比进程要少。所以线程比进程更有效率。但是相对来说，安全性没有那么高。进程的失败不会影响别的进程但是线程就会。

上下文切换区别：
我们需要进程和县城的目的都是想并发的执行程序。为了提高CPU的利用效率，让CPU执行这个程序一段时间，然后执行别的程序一段时间再来执行这个，而不是卡死在一个程序当中. 这个切换的过程需要频繁上下文切换. 进程和现成的上下文切换也有不同的特性。晋城之下的上下文切换。计算机需要替换的东西就比线程要多，除了CPU的寄存器和程序技术，这是进程和县城都有的，进程还需要替换比如页表，文件。因为每个进程独有的一份不一样的。上下切换的时候这些资源都需要替换。但是在线程里只需要替换不共享的部分。

通信区别：
再说一下关于进程间通信和线程之间的通信。
进程间的通信比较麻烦，一般需要借助内核空间，因为内核是管理进程的更上一个层级系统。一种方式就是在内核中的管道沟通就是grep。一个进程可以向管道的一端发送消息，另外一个进程从另外一段收到消息，还有一种方式是消息对立，因为管道是没有格式化的自节流管道命令，对于这一点是一个提升用户可以发送自定义的数据结构，这个时候就需要发送者和接收，提前商定好这个内容格式，还有一种通信方式就是通过内核的存储空间进程共同访问存储空间通过里面读写数据来实现交流。这里举例三种方式县城之间的沟通交流就来得简单很多，因为本来他们就会共享内存，所以可以通过使用全局变量互通

并发操作要注意的问题：
不管是多个线程还是多个进程，在访问同一个资源的时候都需要特殊处理，防止竞争条件和考虑并发一致性的问题。我举几个处理的例子一个就是信号量在C语言里面是semaphore，他的概念是一个全局的计数器能，控制访问有多少进程或者线程正在访问这个资源，还提供这两个系统原子性操作P和V保证并发的安全。


Process is OS's abstraction of a running program. When we run multiple program at the same time, multiple processes
are run concurrently on the same system. Instructions of one process are interleaved with instructions of another process.
This is achieved by mehcanism known as context switching. A uniprocessor system only execute one program code at a time, while multicore can execute
several programs simultaneously. Processes abstracts over processor, main memory, IO devices.

Threads: a rpcess can consist of multiple threads, each running in the contect of the process, share same code and global data. 
Easier to share data between threads and more efficient. Multiple control flow within a process.

concurrency: a system with multiple, simultaneous activities. interleaving execution.

parallelism: use of concurrency to make system run faster. multiple processes running different cores.
- thread level paralellism

  Multicore processors: have several cpus or cors.

  hyperthreading: allows a single cpu to execute multiple threads/ flows of control.

instruciton level parallelism
  - processors execute multiple instructions at one time

</details>

## 进程间的通信
<details>
  管道：匿名管道，一种先进先出的内核文件，进程创建之后可以有读写的描述符进行读写消息，这种匿名的只可以从父进程继承多来，创建的时候把文件给儿子。命名管道，创建一个文件，可以通过文件名使用它，任意进程都可以使用。数据存储在内核里面。
  效率不高。
  
  队列：创建内核中的队列，可以自定义数据结构，需要接受和发送达成一致。这个发送接收消息都是一次系统调用要切换用户态和内核态，开销比较大。
  
  共享内存：本来虚拟地址到物理地址的映射不一样的，一个虚拟空间映射到相同的物理内存里面，不需要一直拷贝。

  信号量：共享内存会有冲突，资源竞争的问题。保证并发的一致性，信号量是一种方式。编程用的semaphore。它一个特殊的计数器，规定这个资源能同时被多少人用，也可以达到程序互斥的目的，
  P操作是-1, V操作是+1，这两个都是原子操作。信号量初始化为1，使用时候做P -1 的操作，<=0表示被占有。 V释放后<0 还有其他在等待，可以唤起。>0表示没有阻塞。0是同步信号，

  信号：处理异常的情况。kill -9 发送编号9的信号给一个进程，用来立即结束它。可以查看具体有几十种信号。有这个信号，系统或者程序收到后做对应的造作，比如终止进程，信号处理函数。

  socket: 跨网络通信。创建socket配置不同网络的通信方式。常见在客户端和服务端之间。可以配置基于TCP/IP字节流或者UDP数据报不同类型或者本地通信的socket。他们的编程模式不一样。tcp有三次握手。
  
</details>
