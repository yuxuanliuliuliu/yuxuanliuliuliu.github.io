## 找到字母中的所有字母异位词

思路：

定长滑动窗口：

- 保持窗口长度对字符串扫描，记录字母出现次数
- 和目标对比是否一样
- 一样的话把 left 加进结果
- left 移除

注意：

- Arrays.euqal(arr1, arr2) 对比长度和里面元素的值

## 无重复字符的最长子串

思路：

时间复杂度：O(n)

空间复杂度: O(1)

- for 遍历右边
- 哈希表记录字符出现个数
- 滑动窗口记录合法无重复子串
- 如果出现个数>1，一直缩小左边界找到合法
- 取 right-left+1 和原长度的最长

错误：

- 缩小左边界要用 while 'abba'

## 接雨水

思路：

- 每一个数列雨水的高度取决于左右最低的柱子 min(leftHeight, rightHeight) - height

暴力和双指针优化：

- 暴力：没遍历一列向两边找 时间复杂度 O(n^2)
- 双指针优化
  - maxLeft[i]记录 i 位置左边最高记录。maxRight[i]记录右边最高
  - 求 i 这一列的雨水高度 min(maxLeft[i], maxRight[i])-height[i]
  - 时间复杂度 O(n) 空间复杂度 O(n)
- 还可以相向双指针优化不用额外空间

单调栈：

时间复杂度：O(n)

空间复杂度: O(n)

- 单调栈可以找到左右第一个比自己大或者小的元素。这里是按行求解。
- 栈内从小到大，记录下标，当前遍历比栈头大找到凹槽了，栈内第二个元素的是左边柱子。通过长宽高求面积
- 可选：遇到相同更新栈内下标，之后求宽度应该用重复元素最右边位置的来计算宽度
- 栈内是遍历过的元素

注意：

- 和栈头的比较要用 while，把所有凹槽都弹出
- pop()前注意判空
