## 二叉树理论篇

满二叉树：二叉树只有 0（叶子结点） 或者 2 度的节点。结点个数 2^k-k

完全二叉树：底层没填满，从左往右填

二叉搜索树：左子树小，右子树大

平衡二叉搜索树：AVL，左右高度差不超过 1，或者空树

存储方式：链式，数组

遍历：

1. 深度优先（递归或者迭代）
   - 前序
   - 中序
   - 后序
2. 广度优先：
   - 层次遍历（迭代法）

## 二叉树递归遍历

1. 确定递归函数
2. 终止条件
3. 单层递归逻辑

## 二叉树迭代遍历

迭代模拟三种深搜遍历顺序

1. 用 stack
2. 中序遍历要特殊处理
   - 用 stack 记录历史记录
   - 用指针遍历二叉树
   - 如果 cur == null, 从 st 里面取出元素处理

## 二叉树层序遍历

广搜

1. 用 queue
2. 或者用 bfs 递归

## 最大二叉树

构造树一般用前序遍历

1. 当前层找到最大值
2. 左边递归
3. 右边递归
4. base case: 可选数组长度为 1 找到叶子结点；或者长度为 0 返回 null

注意：要不断缩小左右边界

## 合并二叉树

https://leetcode.cn/problems/merge-two-binary-trees/description/

前序遍历递归，在 t1 上修改：

- 递归函数：返回合并后的交叉跟节点
- 终止条件：
- 单层逻辑：
  - 中 相加两个节点值为新的节点值
  - 左 合并左树
  - 右 合并右树
- 如果 root1 空，无须合并返回 root2; root2 空，无需合并，返回 root1

时间复杂度：O(min(n,m)) 两棵树最小节点数

空间复杂度：O(min(n,m))

迭代法：

## 二叉搜索树中搜索

遍历方法：

1. 递归法：

   - 确定递归函数参数和返回值，要返回目标节点或者空节点
   - 终止条件：为空的话，或者找到目标节点，返回当前节点
   - 当前层的处理

2. 迭代法

可以不用 stack 或者 queue

用指针一直向右或者向左遍历树直到找到目标，或者返回 null

## 验证二叉搜索树

https://leetcode.cn/problems/validate-binary-search-tree/

判断是不是合法二叉搜索树

1. 递归+数组，中序遍历搜索树应该是有序数组
2. 递归
   - 递归函数
   - 终止条件：root == null return true 空树是二叉搜索树
   - 单层逻辑
     - 左，判断左树是否合法
     - 中
     - 右 判断右是否合法
3. 中序遍历迭代法
