## 重复的子字符串

https://leetcode.cn/problems/repeated-substring-pattern/

KMP 方法：

时间复杂度: O(n)

空间复杂度: O(n)

- 构造前缀表
- 取前缀表[-1]表示最长的前缀和
- 长度-最长前缀剩余是最小重复部分
- 如果不能整除表示不是

移动匹配：

时间复杂度: O(n) java contain 是暴力搜索但是实际不会发生 O(n\*n)的情况。

空间复杂度: O(1)

- 把两个 s 串拼接在一起, 去头去尾。
- find()一下，还有 s 在里面

## KMP 算法

https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/

暴力事件复杂度: O(n\*m)

KMP 时间复杂度：O(n+m)

空间复杂度：O(m) 长度 m 的 next 数组

注意：while 循环必须写在 if 前面。

## 右旋字符

https://kamacoder.com/problempage.php?pid=1065

思路：

- 反转整一行
- 分区反回去

note：

!! while 老是忘记+1 或者-1

scanner.nextLine()返回 String，需要 Integer.parseInt()转为整数

## 反转字符里的单词位置

https://leetcode.cn/problems/reverse-words-in-a-string/

思路：

- 去多余空格
- 反转整句话
- 单个单词反转回去

时间复杂度: O(n)

空间复杂度: O(1)

Note：

System.arraycopy 用来处理数组复制最有效率的方法。ArrayList 底层用的它。

1. 数组为切片 2. 数组拼接 3. 自身移动 System.arraycopy(nums, 3, nums, 2, 2);

```
public static void native arraycopy(
    Object src,      // 1. 源数组 (从哪里复制)
    int    srcPos,   // 2. 源数组的起始位置 (从第几个开始)
    Object dest,     // 3. 目标数组 (复制到哪里去)
    int    destPos,  // 4. 目标数组的起始位置 (贴到第几个位置)
    int    length    // 5. 复制的长度 (一共要复制多少个元素)
);
```

**char[]** 数组是可变，string 不可变

## 替换字符

https://kamacoder.com/problempage.php?pid=1064

思路：

- 找到所有数字，扩容
- 从后向前便利填充 result，避免从前到后数组一直挪动(时间复杂度是 O(n^2))

时间复杂度：O(n)

空间复杂度：O(1)

```
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        char[] words = line.toCharArray();
        int count = 0;
        for(char c : words){
            if ( '0'<=c && c <= '9'){
                count++;
            }
        }
        int newSize = (words.length - count) + count * 6;
        char[] result = new char[newSize];
        int i = words.length -1;
        int j = result.length -1;
        char[] number = new char[]{'n', 'u', 'm', 'b', 'e', 'r'};   //错错错！char[] number = new char[]{n, u, m, b, e, r};
        while(i >= 0){
            if( '0' <=words[i] && words[i] <= '9' ){
                for(int k = 5; k >= 0; k --){
                    result[j--] = number[k];
                }
            }
            else{
                result[j--] = words[i];
            }
            i--;
        }
        System.out.println(new String(result));

    }
}
```

## 反转字符 II

https://leetcode.cn/problems/reverse-string-ii/description/

思路：

- 遍历每一段走 2K
- i+k < length，说明够 k 个位置，反转 i 到 i+k。
- i+k > length, 说明剩余不够 k 个位置，反转 i 到 length

时间复杂度：O(n)

空间复杂度: O(n)

错题：
class Solution {
public String reverseStr(String s, int k) {
char[] str = s.toCharArray();
for(int i = 0; i < str.length; i+=2\*k){
if(i+k < str.length){
reverse(str, i, i+k-1);
}
else{
reverse(str, i, str.length -1);
}
}
return new String(str);
}

    public void reverse(char[] str, int start, int end){
        for(int i = start, j = end; i < j; i++, j--) {
            char temp = str[start]; //要用i, j
            str[start] = str[end];
            str[end] = temp;
        }
    }

}

## 反转字符

[https://leetcode.cn/problems/reverse-string/submissions/686744919/](https://leetcode.cn/problems/reverse-string/description/)

思路：左右双指针反转

时间复杂度：O(n)

空间复杂度：O(1)
