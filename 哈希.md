## 四数之和

https://leetcode.cn/problems/4sum/

时间复杂度：O(n^3) 降一个维度

思路：

- 固定前两个数
- 双指针找剩下两个数
- 和三数的思路一样

注意：

- 四数和用 long 类型不然会溢出
- 剪枝
- 正数 target 才能剪纸，负数不行

## 三数之和

https://leetcode.cn/problems/3sum/

思路

- 数组排序
- 固定数 1，双指针从 i+1 到 length-1 找数 2 数 3
- 三个去重逻辑要加上
- 数 1 判断 nums(i)==(i-1) continue; 当前的排列已经被记录了

时间复杂度: O(n^2)

空间复杂度: O(1)

## 赎金信

https://leetcode.cn/problems/ransom-note/

思路：

- 判断一个字母是否在另外一个里面出现过，用哈希法
- 遍历一个，记录字母:出现次数
- 遍历另外一个做-1
- 如果没出现，或者次数<=0，返回 false
- 遍历完所有返回 true

时间复杂度：O(n) 遍历两个数组

空间复杂度：O(n) 假设没有重复字符

暴力解法： 时间复杂度 O(n^2) 空间复杂度: O(1)

```
//数组哈希，只有小写字母优先用数组
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] record = new int[26];

        for (int i = 0; i < magazine.length(); i++) {
            char c = magazine.charAt(i);
            record[c - 'a']++;
        }

        for (char c : ransomNote.toCharArray()) {
            if (record[c - 'a'] > 0) {
                record[c - 'a']--;
            } else {
                return false;
            }
        }
        return true;
    }
}

// 用map实现开销比数组大
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> record = new HashMap<>();
        //遍历string的一种方式
        // for(char c : magazine.toCharArray()){
        //     record.put(c, record.getOrDefault(c, 0) + 1);
        // }

        // 第二种方式
        for(int i = 0; i < magazine.length(); i ++){
            char c = magazine.charAt(i);
            record.put(c, record.getOrDefault(c, 0) + 1);
        }

        for(char c : ransomNote.toCharArray()){
            if(record.containsKey(c) && record.get(c) >0){
                record.put(c, record.get(c) - 1);
            }
            else{
                return false;
            }
        }
        return true;
    }
}

```

## 四数之和

https://leetcode.cn/problems/4sum-ii/

思路：

- 遍历两个数组，map 记录两数和和出现次数
- 遍历另两个数组找-sum 有没有出现过

时间复杂度：O(n^2) 遍历两个数组

空间复杂度：O(n^2) 最坏情况没有重复的和

```
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> record = new HashMap<>();
        for(int num1:nums1){
            for(int num2:nums2){
                int sum = num1 + num2;
                record.put(sum, record.getOrDefault(sum, 0) + 1);
            }
        }

        int count = 0;
        for(int num3: nums3){
            for(int num4: nums4){
                int sum = num3 + num4;
                count += record.getOrDefault(-sum, 0);
            }
        }
        return count;
    }
}
```

## 两数之和

https://leetcode.cn/problems/two-sum/description/

思路：

- 用 map 存数字：数值对应下标，判断目标数字有没有出现过
- 出现返回两个下标
- 没有把当前遍历加入 map 中
- 相当于遍历右边数，找左边数是不是有 target - num[i]

时间复杂度：O(n) 遍历一遍

空间复杂度：O(n)

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> record = new HashMap<>();
        int[] res = new int[2];
        for(int i = 0; i < nums.length; i++){
            int b = target - nums[i];
            if(record.containsKey(b)){
                res[0] = i;
                res[1] = record.get(b);
                break;
            }
            else{
                record.put(nums[i], i);
            }
        }
        return res;
    }
}
```

错题：

- 先查询后加入，不然会重复用同一个元素`nums = [3,2,4], target = 6`, `nums = [3,3], target = 6`这两种情况都会返回 0，0

## 有效的字母异位词

https://leetcode.cn/problems/valid-anagram/

思路：

- 26 大小数组，下标映射 0 对应字母 a 出现的次数
- 一个数组遍历记录出现次数+1
- 遍历另外一个数组做-1
- 遍历结果是不是为 0

```
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int [26];
        for(int i = 0; i < s.length(); i++){
            int c = s.charAt(i) - 'a';
            record[c] += 1;
        }

        for(int i = 0; i < t.length(); i++){
            int c = t.charAt(i) - 'a';
            record[c] -= 1;
            if(record[c] < 0) return false;
        }
        for(int i = 0; i < 26; i++){
            if(record[i] != 0) return false;
        }
        return true;
    }
}
```

## 两个数组的交集

https://leetcode.cn/problems/intersection-of-two-arrays/

思路

- 用 set 记录出现过的字符，自动去重
- 遍历一个单词 set 里面记录出现的字符
- 遍历另外一个数组找相同出现过的加入 result set 里面

时间复杂度：O(n) + O(m) + O(min(n,m)) 三个遍历

空间复杂度: O(n)

```
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> record = new HashSet<>();
        for(int num:nums1){
            record.add(num);
        }
        Set<Integer> result = new HashSet<>();
        for(int num:nums2){
            if(record.contains(num)){
                result.add(num);
            }
        }
        int[] array = result.stream().mapToInt(Integer::intValue).toArray();  // set转成数组

        int[] array = new int[result.size()];  //或者这样
        int j = 0;
        for(int num: result){
            array[j++] = num;
        }
        return array;
    }
}
```

## 快乐数

思路：

- 用 set 判断是否有循环
- getDigitsSum(n) 算此刻平方和结果
- 结果为 1 返回 true
- 如果 set 里有记录，说明有循环，返回 false
- 否则加入 set 记录， 用当前的和，进入下一次循环

时间复杂度：O(logn) 数字的位数，n = 10^k 是 k+1 位，位数是 log(n)，只要是 getDigitsSum 的时间. while 会压缩成 O(1)的时间，只在小范围里面循环。

空间复杂度：O(logn) 或者 O（1）会是一个常数，不会随着 n 增大而无限增大。

```
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while(true){
            int sum = this.getDigitsSum(n);
            if(record.contains(sum)) return false;
            if(sum == 1) return true;
            record.add(sum);
            n = sum;
        }

    }
    int getDigitsSum(int n){
        int sum = 0;
        while(n > 0){
            int digit = n % 10;
            sum += digit * digit;
            n = n /10;
        }
        return sum;
    }
}
```
