# 二分查找
**能解决的问题：** 找到第一个复合要求的元素，第一个大于target的元素，过程中根据判断条件不断缩小左右边界，缩小寻找范围。

**暴力做法查找：** 全部遍历O(n)，没有利用有序的性质

**前提：** 如果数据有序，可以考虑二分查找。如果有重复，不保证唯一答案。

**注意的点：** 循环不变量

**时间复杂度** ：O(logn)
- 每次把问题规模砍半直到剩一个元素
- n/2^k = 1 -> k = log(n)
- 最多O(logn)次查询

**几种实现方法**： 左闭右闭，左闭右开

[704 二分查找](https://leetcode.cn/problems/binary-search/description/)


```

// 左闭右闭写法
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length -1;
        while(left<= right){
            int mid = left + (right -left)/2;
            if(nums[mid] < target){ //易错：mid是下标，要比较nums[mid]
                left = mid +1;
            }
            else if(nums[mid]>target){
                right = mid -1;
            }
            else{
                return mid;
            }
        }
        return -1;
    }
}

// 左闭右开写法
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length -1;
        while(left< right){
            int mid = left + (right -left)/2;
            if(nums[mid] < target){ //易错：mid是下标，要比较nums[mid]
                left = mid +1;
            }
            else if(nums[mid]>target){
                right = mid;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
}

// 错题
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        while(left< right){
            int mid = left + (right -left)/2;
            if(nums[mid] < target){
                left = mid +1;
            }
            if(nums[mid]>target){ // if与下一个else 配对，没有互斥，逻辑错误
                right = mid;
            }
            else{
                return mid;
            }
        }
        return -1;
    }

```


