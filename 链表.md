# 链表

## 移除链表元素
[203移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

**思路：**
- cur.next 指向 cur.next.next
- 不加虚拟头节点，需要分情况处理头节点和其他节点
- 使用虚拟头节点，设计到对链表修改的操作要考虑加dummy 比如增删移动改

**不加虚拟头节点：**
时间复杂度：O(n): 遍历一遍
空间复杂度：O(1)

```
  public ListNode removeElements(ListNode head, int val) {
      while (head != null && head.val == val) { // 移除头节点要用while，eg: 1111234 移除1
          head = head.next;
      }
      ListNode cur = head;
      while (cur != null && cur.next != null) { // 后面取值，注意判空
          if (cur.next.val == val) {
              cur.next = cur.next.next;
          } else {
              cur = cur.next;
          }
      }
      return head;
  }
```

**虚拟头节点：**
时间复杂度：O(n)
空间复杂度：O(1)

```
  public ListNode removeElements(ListNode head, int val) {
      ListNode dummy = new ListNode();
      dummy.next = head;
      ListNode cur = dummy;
      while(cur != null && cur.next != null){
          if(cur.next.val == val){
              cur.next = cur.next.next;
          }
          else{
              cur = cur.next;
          }
      }
      return dummy.next; // 注意返回头节点是dummy.next
  }
```

## 设计链表
[707设计链表](https://leetcode.cn/problems/design-linked-list/)

**注意：** 
- 不确定循环条件可以带入0这种边界条件判断
- 修改列表推荐用dummy，不然对边界条件eg空数组，头节点 做特殊处理
- 不要忘了修改size
  
```

class MyLinkedList {
    
    Node dummyHead;
    int size;

    public MyLinkedList() {
        this.size = 0;
        this.dummyHead = new Node(0); //虚拟头节点
    }

    class Node { //node类
        int val;
        Node next;

        public Node() {
        }

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    public int get(int index) {
        if (index < 0 || index >= this.size) { // 判断非法下标
            return -1;
        }
        Node cur = this.dummyHead.next;
        while (index > 0) {     //带入0判断一下边界
            cur = cur.next;
            index--;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        Node newNode = new Node(val);
        newNode.next = dummyHead.next; //注意顺序
        this.dummyHead.next = newNode;
        this.size++;
    }

    public void addAtTail(int val) { // 不用dummy需要特殊处理，思考list是空的情况
        Node newNode = new Node(val);
        Node cur = dummyHead;
        while (cur.next != null) {
            cur = cur.next;
        }
        cur.next = newNode;
        this.size++;
    }

    public void addAtIndex(int index, int val) {
        if (index > this.size) {    //判断下标
            return;
        }
        if (index < 0) {
            index = 0;
        }
        Node newNode = new Node(val);
        Node cur = this.dummyHead;
        while (index > 0) {
            cur = cur.next;
            index--;
        }
        newNode.next = cur.next;
        cur.next = newNode;
        this.size++;
    }

    public void deleteAtIndex(int index) {
        if (index >= this.size || index < 0) {
            return;
        }
        Node cur = this.dummyHead;
        while (index > 0) {
            cur = cur.next;
            index--;
        }
        cur.next = cur.next.next;
        this.size--;
    }
}


```

## 反转链表
[206反转列表](https://leetcode.cn/problems/reverse-linked-list/)

**遍历双指针写法：**
时间复杂度：O(n): 遍历一遍
空间复杂度: O(1)

```
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
```
**递归写法：**
时间复杂度：O(n): 遍历一遍
空间复杂度: O(n)

```
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(head, null);
    }
    public ListNode reverse(ListNode cur, ListNode pre){
        if( cur == null) return pre;  // BASE CASE
        ListNode temp = cur.next;  //改变当前cur的指向
        cur.next = pre;
        return reverse(temp, cur);  //递归状态转移
    }
}
```


