# 链表

## 移除链表元素
[203移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

**思路：**
- cur.next 指向 cur.next.next
- 不加虚拟头节点，需要分情况处理头节点和其他节点
- 使用虚拟头节点，设计到对链表修改的操作要考虑加dummy 比如增删移动改

**不加虚拟头节点：**
时间复杂度：O(n): 遍历一遍
空间复杂度：O(1)

```
  public ListNode removeElements(ListNode head, int val) {
      while (head != null && head.val == val) { // 移除头节点要用while，eg: 1111234 移除1
          head = head.next;
      }
      ListNode cur = head;
      while (cur != null && cur.next != null) { // 后面取值，注意判空
          if (cur.next.val == val) {
              cur.next = cur.next.next;
          } else {
              cur = cur.next;
          }
      }
      return head;
  }
```

**虚拟头节点：**
时间复杂度：O(n)
空间复杂度：O(1)

```
  public ListNode removeElements(ListNode head, int val) {
      ListNode dummy = new ListNode();
      dummy.next = head;
      ListNode cur = dummy;
      while(cur != null && cur.next != null){
          if(cur.next.val == val){
              cur.next = cur.next.next;
          }
          else{
              cur = cur.next;
          }
      }
      return dummy.next; // 注意返回头节点是dummy.next
  }
```

## 设计链表
<details>
[707设计链表](https://leetcode.cn/problems/design-linked-list/)

**注意：** 
- 不确定循环条件可以带入0这种边界条件判断
- 修改列表推荐用dummy，不然对边界条件eg空数组，头节点 做特殊处理
- 不要忘了修改size
  
```

class MyLinkedList {
    
    Node dummyHead;
    int size;

    public MyLinkedList() {
        this.size = 0;
        this.dummyHead = new Node(0); //虚拟头节点
    }

    class Node { //node类
        int val;
        Node next;

        public Node() {
        }

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    public int get(int index) {
        if (index < 0 || index >= this.size) { // 判断非法下标
            return -1;
        }
        Node cur = this.dummyHead.next;
        while (index > 0) {     //带入0判断一下边界
            cur = cur.next;
            index--;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        Node newNode = new Node(val);
        newNode.next = dummyHead.next; //注意顺序
        this.dummyHead.next = newNode;
        this.size++;
    }

    public void addAtTail(int val) { // 不用dummy需要特殊处理，思考list是空的情况
        Node newNode = new Node(val);
        Node cur = dummyHead;
        while (cur.next != null) {
            cur = cur.next;
        }
        cur.next = newNode;
        this.size++;
    }

    public void addAtIndex(int index, int val) {
        if (index > this.size) {    //判断下标
            return;
        }
        if (index < 0) {
            index = 0;
        }
        Node newNode = new Node(val);
        Node cur = this.dummyHead;
        while (index > 0) {
            cur = cur.next;
            index--;
        }
        newNode.next = cur.next;
        cur.next = newNode;
        this.size++;
    }

    public void deleteAtIndex(int index) {
        if (index >= this.size || index < 0) {
            return;
        }
        Node cur = this.dummyHead;
        while (index > 0) {
            cur = cur.next;
            index--;
        }
        cur.next = cur.next.next;
        this.size--;
    }
}
```
</details>

## 反转链表
[206反转列表](https://leetcode.cn/problems/reverse-linked-list/)

**遍历双指针写法：**
时间复杂度：O(n): 遍历一遍
空间复杂度: O(1)

```
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
```
**递归写法：**
时间复杂度：O(n): 遍历一遍
空间复杂度: O(n)

```
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(head, null);
    }
    public ListNode reverse(ListNode cur, ListNode pre){
        if( cur == null) return pre;  // BASE CASE
        ListNode temp = cur.next;  //改变当前cur的指向
        cur.next = pre;
        return reverse(temp, cur);  //递归状态转移
    }
}
```
## 两两交链表节点

[两两交换链表节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

**思路：** 移动cur，交换cur后面两个

时间复杂度：O(n) 遍历整个列表
空间复杂度: O(1)

```
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode cur = dummy;
        while(cur.next != null && cur.next.next != null){ // 如果后面没有两个节点不用交换了
            System.out.println(cur.val); //  DEBUG 死循环
            ListNode temp1 = cur.next;
            ListNode temp2 = cur.next.next.next;
            cur.next = cur.next.next;
            cur.next.next = temp1;
            temp1.next = temp2;
            cur = cur.next.next;
        }
        return dummy.next;
    }
}
```
## 移除倒数第n个元素

https://leetcode.cn/problems/remove-nth-node-from-end-of-list/

思路： 快指针比满指针多走n+1步，慢指针移动到n前一个位置，删除slow下一个

时间复杂素: O(n) 遍历整个数组

空间复杂度：O(1)

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode fast = dummy, slow = dummy;
        n++;
        while(n>0 && fast!= null){
            fast = fast.next;
            n--;
        }
        while(fast!=null){
            System.out.println("slow:" + slow.val + "fast:" + fast.val); // DEBUG
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```

## 环形列表

https://leetcode.cn/problems/linked-list-cycle-ii/

思路：fast走两格，slow走一格，两格速度差为1，如果有环快指针一定会追上满指针。如果没有环，快指针会先碰到null结束程序。

时间复杂度：O(n) 所有指针走的距离总和小余2n

空间复杂度：O(1)

```
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) { //如果碰到null说明没有环
            fast = fast.next.next;
            slow = slow.next;
            if (slow == fast) {
                ListNode index1 = head;
                ListNode index2 = fast;
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```

## 交叉列表

思路：先算A和B的长度，算差对其尾部，遍历判断元素是否一样

时间复杂度：O(n+m) 遍历两个列表
空间复杂度：O(1)

<details>

```
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        int lengthA = 0;
        while(curA != null){
            lengthA++;
            curA = curA.next;
        }
        int lengthB = 0;
        ListNode curB = headB;
        while(curB != null){
            lengthB++;
            curB = curB.next;
        }

        curA = headA; //重置指针
        curB = headB;

        //固定curA指向更长的链表
        if(lengthA < lengthB){
            curA = headB;
            curB = headA;
            int temp = lengthB;
            lengthB = lengthA;
            lengthA = temp;
        }
        int n = lengthA - lengthB;
        
        while(n > 0){
            curA = curA.next;
            n--;
        }

        while(curA != null && curB != null){
            if(curA == curB){
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}
```

</details>

